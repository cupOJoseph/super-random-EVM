"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_foreach_1 = __importDefault(require("lodash.foreach"));
const zos_lib_1 = require("zos-lib");
const ControllerFor_1 = __importDefault(require("../models/network/ControllerFor"));
const log = new zos_lib_1.Logger('scripts/status');
function status({ network, txParams = {}, networkFile }) {
    return __awaiter(this, void 0, void 0, function* () {
        const controller = ControllerFor_1.default(network, txParams, networkFile);
        log.info(`Project status for network ${network}`);
        if (!(yield appInfo(controller)))
            return;
        if (!(yield versionInfo(controller.networkFile)))
            return;
        yield dependenciesInfo(controller.networkFile);
        yield contractsInfo(controller);
        yield proxiesInfo(controller.networkFile);
    });
}
exports.default = status;
// TODO: Find a nice home for all these functions :)
function appInfo(controller) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!controller.isPublished)
            return true;
        if (!controller.appAddress) {
            log.warn(`Application is not yet deployed to the network`);
            return false;
        }
        yield controller.fetchOrDeploy(controller.currentVersion);
        log.info(`Application is deployed at ${controller.appAddress}`);
        log.info(`- Package ${controller.packageFile.name} is at ${controller.networkFile.packageAddress}`);
        return true;
    });
}
function versionInfo(networkFile) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!networkFile.isPublished)
            return true;
        if (networkFile.hasMatchingVersion()) {
            log.info(`- Deployed version ${networkFile.version} matches the latest one defined`);
            return true;
        }
        else {
            log.info(`- Deployed version ${networkFile.version} is out of date (latest is ${networkFile.packageFile.version})`);
            return false;
        }
    });
}
function contractsInfo(controller) {
    return __awaiter(this, void 0, void 0, function* () {
        log.info('Application contracts:');
        // Bail if there are no contracts at all
        if (!controller.packageFile.hasContracts() && !controller.networkFile.hasContracts()) {
            log.info(`- No contracts registered`);
            return;
        }
        // Log status for each contract in package file
        lodash_foreach_1.default(controller.packageFile.contracts, function (contractName, contractAlias) {
            const isDeployed = controller.isContractDeployed(contractAlias);
            const hasChanged = controller.hasContractChanged(contractAlias);
            const fullName = contractName === contractAlias ? contractAlias : `${contractAlias} (implemented by ${contractName})`;
            if (!isDeployed) {
                log.warn(`- ${fullName} is not deployed`);
            }
            else if (hasChanged) {
                log.error(`- ${fullName} is out of date with respect to the local version`);
            }
            else {
                log.info(`- ${fullName} is deployed and up to date`);
            }
        });
        // Log contracts in network file missing from package file
        controller.networkFile.contractAliasesMissingFromPackage()
            .forEach((contractAlias) => log.warn(`- ${contractAlias} will be removed on next push`));
    });
}
function dependenciesInfo(networkFile) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!networkFile.isPublished)
            return;
        const packageFile = networkFile.packageFile;
        if (!packageFile.hasDependencies() && !networkFile.hasDependencies())
            return;
        log.info('Application dependencies:');
        lodash_foreach_1.default(packageFile.dependencies, (requiredVersion, dependencyName) => {
            const msgHead = `- ${dependencyName}@${requiredVersion}`;
            if (!networkFile.hasDependency(dependencyName)) {
                log.info(`${msgHead} is required but is not linked`);
            }
            else if (networkFile.dependencyHasMatchingCustomDeploy(dependencyName)) {
                log.info(`${msgHead} is linked to a custom deployment`);
            }
            else if (networkFile.dependencyHasCustomDeploy(dependencyName)) {
                log.info(`${msgHead} is linked to a custom deployment of a different version (${networkFile.getDependency(dependencyName).version})`);
            }
            else if (networkFile.dependencySatisfiesVersionRequirement(dependencyName)) {
                const actualVersion = networkFile.getDependency(dependencyName).version;
                if (actualVersion === requiredVersion) {
                    log.info(`${msgHead} is linked`);
                }
                else {
                    log.info(`${msgHead} is linked to version ${actualVersion}`);
                }
            }
            else {
                log.info(`${msgHead} is linked to a different version (${networkFile.getDependency(dependencyName).version})`);
            }
        });
        lodash_foreach_1.default(networkFile.dependenciesNamesMissingFromPackage, (dependencyName) => {
            log.info(`- ${dependencyName} will be unlinked on next push`);
        });
    });
}
function proxiesInfo(networkFile) {
    return __awaiter(this, void 0, void 0, function* () {
        log.info('Deployed proxies:');
        if (!networkFile.hasProxies()) {
            log.info('- No proxies created');
            return;
        }
        networkFile.getProxies().forEach((proxy) => log.info(`- ${proxy.package}/${proxy.contract} at ${proxy.address} version ${proxy.version}`));
    });
}
//# sourceMappingURL=status.js.map