"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_frompairs_1 = __importDefault(require("lodash.frompairs"));
const lodash_map_1 = __importDefault(require("lodash.map"));
const lodash_flatten_1 = __importDefault(require("lodash.flatten"));
const lodash_uniq_1 = __importDefault(require("lodash.uniq"));
const zos_lib_1 = require("zos-lib");
const semver_1 = __importDefault(require("semver"));
const npm_programmatic_1 = __importDefault(require("npm-programmatic"));
const ZosPackageFile_1 = __importDefault(require("../files/ZosPackageFile"));
const ZosNetworkFile_1 = __importDefault(require("../files/ZosNetworkFile"));
const log = new zos_lib_1.Logger('Dependency');
class Dependency {
    static fromNameWithVersion(nameAndVersion) {
        const [name, version] = nameAndVersion.split('@');
        return new this(name, version);
    }
    static satisfiesVersion(version, requirement) {
        return !requirement || version === requirement || semver_1.default.satisfies(version, requirement);
    }
    static install(nameAndVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            log.info(`Installing ${nameAndVersion} via npm...`);
            yield npm_programmatic_1.default.install([nameAndVersion], { save: true, cwd: process.cwd() });
            return this.fromNameWithVersion(nameAndVersion);
        });
    }
    constructor(name, requirement) {
        this.name = name;
        this._networkFiles = {};
        const packageVersion = this.getPackageFile().version;
        this._validateSatisfiesVersion(packageVersion, requirement);
        this.version = packageVersion;
        this.nameAndVersion = `${name}@${packageVersion}`;
        this.requirement = requirement || tryWithCaret(packageVersion);
    }
    deploy(txParams) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = semver_1.default.coerce(this.version).toString();
            const project = yield zos_lib_1.PackageProject.fetchOrDeploy(version, txParams, {});
            // REFACTOR: Logic for filling in solidity libraries is partially duplicated from network base controller,
            // this should all be handled at the Project level. Consider adding a setImplementations (plural) method
            // to Projects, which handle library deployment and linking for a set of contracts altogether.
            const contracts = lodash_map_1.default(this.getPackageFile().contracts, (contractName, contractAlias) => [zos_lib_1.Contracts.getFromNodeModules(this.name, contractName), contractAlias]);
            const pipeline = [
                (someContracts) => lodash_map_1.default(someContracts, ([contract]) => zos_lib_1.getSolidityLibNames(contract.schema.bytecode)),
                (someContracts) => lodash_flatten_1.default(someContracts),
                (someContracts) => lodash_uniq_1.default(someContracts),
            ];
            const libraryNames = pipeline.reduce((xs, f) => f(xs), contracts);
            const libraries = lodash_frompairs_1.default(yield Promise.all(lodash_map_1.default(libraryNames, (libraryName) => __awaiter(this, void 0, void 0, function* () {
                const implementation = yield project.setImplementation(zos_lib_1.Contracts.getFromNodeModules(this.name, libraryName), libraryName);
                return [libraryName, implementation.address];
            }))));
            yield Promise.all(lodash_map_1.default(contracts, ([contract, contractAlias]) => __awaiter(this, void 0, void 0, function* () {
                contract.link(libraries);
                yield project.setImplementation(contract, contractAlias);
            })));
            return project;
        });
    }
    getPackageFile() {
        if (!this._packageFile) {
            const filename = `node_modules/${this.name}/zos.json`;
            if (!zos_lib_1.FileSystem.exists(filename)) {
                throw Error(`Could not find a zos.json file for '${this.name}'. Make sure it is provided by the npm package.`);
            }
            this._packageFile = new ZosPackageFile_1.default(filename);
        }
        return this._packageFile;
    }
    getNetworkFile(network) {
        if (!this._networkFiles[network]) {
            const filename = this._getNetworkFilePath(network);
            if (!zos_lib_1.FileSystem.exists(filename)) {
                throw Error(`Could not find a zos file for network '${network}' for '${this.name}'`);
            }
            this._networkFiles[network] = new ZosNetworkFile_1.default(this.getPackageFile(), network, filename);
            this._validateSatisfiesVersion(this._networkFiles[network].version, this.requirement);
        }
        return this._networkFiles[network];
    }
    isDeployedOnNetwork(network) {
        const filename = this._getNetworkFilePath(network);
        if (!zos_lib_1.FileSystem.exists(filename))
            return false;
        return !!this.getNetworkFile(network).packageAddress;
    }
    _getNetworkFilePath(network) {
        return `node_modules/${this.name}/zos.${network}.json`;
    }
    _validateSatisfiesVersion(version, requirement) {
        if (!Dependency.satisfiesVersion(version, requirement)) {
            throw Error(`Required dependency version ${requirement} does not match version ${version}`);
        }
    }
}
exports.default = Dependency;
function tryWithCaret(version) {
    const cleaned = semver_1.default.clean(version);
    return cleaned ? `^${cleaned}` : version;
}
//# sourceMappingURL=Dependency.js.map