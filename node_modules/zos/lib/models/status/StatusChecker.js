"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventsFilter_1 = __importDefault(require("./EventsFilter"));
const StatusFetcher_1 = __importDefault(require("./StatusFetcher"));
const StatusComparator_1 = __importDefault(require("./StatusComparator"));
const zos_lib_1 = require("zos-lib");
const log = new zos_lib_1.Logger('StatusChecker');
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
class StatusChecker {
    static fetch(networkFile, txParams = {}) {
        const fetcher = new StatusFetcher_1.default(networkFile);
        return new this(fetcher, networkFile, txParams);
    }
    static compare(networkFile, txParams = {}) {
        const comparator = new StatusComparator_1.default();
        return new this(comparator, networkFile, txParams);
    }
    constructor(visitor, networkFile, txParams = {}) {
        this.visitor = visitor;
        this.txParams = txParams;
        this.networkFile = networkFile;
        this.packageName = this.networkFile.packageFile.name;
    }
    setProject() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { packageAddress, appAddress, version } = this.networkFile;
                if (!this.project) {
                    this.project = yield zos_lib_1.AppProject.fetchOrDeploy(this.packageName, this.networkFile.version, this.txParams, { appAddress, packageAddress });
                }
                return this.project;
            }
            catch (error) {
                error.message = `Cannot fetch project contract from address ${this.networkFile.appAddress}: ${error.message}`;
                throw error;
            }
        });
    }
    call() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setProject();
            log.info(`Comparing status of project ${(yield this.project.getProjectPackage()).address} ...\n`);
            yield this.checkApp();
            this.visitor.onEndChecking();
        });
    }
    checkApp() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkVersion();
            yield this.checkPackage();
            yield this.checkProvider();
            yield this.checkImplementations();
            yield this.checkDependencies();
        });
    }
    checkVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const observed = this.project.version;
            const expected = this.networkFile.version;
            if (!zos_lib_1.semanticVersionEqual(observed, expected))
                this.visitor.onMismatchingVersion(expected, observed);
        });
    }
    checkPackage() {
        return __awaiter(this, void 0, void 0, function* () {
            const observed = this.project.package.address;
            const expected = this.networkFile.packageAddress;
            if (observed !== expected)
                this.visitor.onMismatchingPackage(expected, observed);
        });
    }
    checkProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentDirectory = yield this.project.getCurrentDirectory();
            const observed = currentDirectory.address;
            const expected = this.networkFile.providerAddress;
            if (observed !== expected)
                this.visitor.onMismatchingProvider(expected, observed);
        });
    }
    checkDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            const dependenciesInfo = yield this._fetchOnChainPackages();
            dependenciesInfo.forEach((info) => this._checkRemoteDependency(info));
            this._checkUnregisteredLocalDependencies(dependenciesInfo);
        });
    }
    checkImplementations() {
        return __awaiter(this, void 0, void 0, function* () {
            const implementationsInfo = yield this._fetchOnChainImplementations();
            yield Promise.all(implementationsInfo.map((info) => __awaiter(this, void 0, void 0, function* () {
                const { address } = info;
                const bytecode = yield zos_lib_1.ZWeb3.getCode(address);
                return yield (zos_lib_1.isSolidityLib(bytecode)
                    ? this._checkRemoteSolidityLibImplementation(info, bytecode)
                    : this._checkRemoteContractImplementation(info, bytecode));
            })));
            this._checkUnregisteredLocalImplementations(implementationsInfo);
        });
    }
    _checkRemoteContractImplementation({ alias, address }, bytecode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.networkFile.hasContract(alias)) {
                this._checkContractImplementationAddress(alias, address);
                this._checkContractImplementationBytecode(alias, address, bytecode);
            }
            else {
                yield this.visitor.onMissingRemoteImplementation('none', 'one', { alias, address });
            }
        });
    }
    _checkContractImplementationAddress(alias, address) {
        const expected = this.networkFile.contract(alias).address;
        if (address !== expected)
            this.visitor.onMismatchingImplementationAddress(expected, address, { alias, address });
    }
    _checkContractImplementationBytecode(alias, address, bytecode) {
        const expected = this.networkFile.contract(alias).bodyBytecodeHash;
        const observed = zos_lib_1.bytecodeDigest(bytecode);
        if (observed !== expected)
            this.visitor.onMismatchingImplementationBodyBytecode(expected, observed, { alias, address, bodyBytecodeHash: observed });
    }
    _checkRemoteSolidityLibImplementation({ alias, address }, bytecode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.networkFile.hasSolidityLib(alias)) {
                this._checkSolidityLibImplementationAddress(alias, address);
                this._checkSolidityLibImplementationBytecode(alias, address, bytecode);
            }
            // TODO: implement missing remote solidity libs validation
            // else this.visitor.onMissingRemoteImplementation('none', 'one', { alias, address })
        });
    }
    _checkSolidityLibImplementationAddress(alias, address) {
        const expected = this.networkFile.solidityLib(alias).address;
        if (address !== expected)
            this.visitor.onMismatchingImplementationAddress(expected, address, { alias, address });
    }
    _checkSolidityLibImplementationBytecode(alias, address, bytecode) {
        const expected = this.networkFile.solidityLib(alias).bodyBytecodeHash;
        const observed = zos_lib_1.bytecodeDigest(zos_lib_1.replaceSolidityLibAddress(bytecode, address));
        if (observed !== expected)
            this.visitor.onMismatchingImplementationBodyBytecode(expected, observed, { alias, address, bodyBytecodeHash: observed });
    }
    _checkUnregisteredLocalImplementations(implementationsInfo) {
        const foundAliases = implementationsInfo.map((info) => info.alias);
        this.networkFile.contractAliases
            .filter((alias) => !foundAliases.includes(alias))
            .forEach((alias) => {
            const { address } = this.networkFile.contract(alias);
            this.visitor.onUnregisteredLocalImplementation('one', 'none', { alias, address });
        });
    }
    _checkRemoteDependency({ name, version, package: address }) {
        if (this.networkFile.hasDependency(name)) {
            this._checkDependencyAddress(name, address);
            this._checkDependencyVersion(name, version);
        }
        else
            this.visitor.onMissingDependency('none', 'one', { name, address, version });
    }
    _checkDependencyAddress(name, address) {
        const expected = this.networkFile.getDependency(name).package;
        if (address !== expected)
            this.visitor.onMismatchingDependencyAddress(expected, address, { name, address });
    }
    _checkDependencyVersion(name, version) {
        const expected = this.networkFile.getDependency(name).version;
        if (!zos_lib_1.semanticVersionEqual(version, expected))
            this.visitor.onMismatchingDependencyVersion(expected, version, { name, version });
    }
    _checkUnregisteredLocalDependencies(dependenciesInfo) {
        const foundDependencies = dependenciesInfo.map((dependency) => dependency.name);
        this.networkFile.dependenciesNames
            .filter((name) => !foundDependencies.includes(name))
            .forEach((name) => {
            const dependency = this.networkFile.getDependency(name);
            this.visitor.onUnregisteredDependency('one', 'none', Object.assign({}, dependency, { name }));
        });
    }
    // TS-TODO: type for event?
    _fetchOnChainImplementations() {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = new EventsFilter_1.default();
            const directory = yield this.project.getCurrentDirectory();
            const allEvents = yield filter.call(directory.contract, 'ImplementationChanged');
            const contractsAlias = allEvents.map((event) => event.returnValues.contractName);
            const events = allEvents
                .filter((event, index) => contractsAlias.lastIndexOf(event.returnValues.contractName) === index)
                .filter((event) => event.returnValues.implementation !== ZERO_ADDRESS)
                .map((event) => ({ alias: event.returnValues.contractName, address: event.returnValues.implementation }));
            return events;
        });
    }
    _fetchOnChainPackages() {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = new EventsFilter_1.default();
            const app = this.project.getApp();
            const allEvents = yield filter.call(app.appContract, 'PackageChanged');
            const filteredEvents = allEvents
                .filter((event) => event.returnValues.package !== ZERO_ADDRESS)
                .filter((event) => event.returnValues.providerName !== this.packageName)
                .map((event) => ({
                name: event.returnValues.providerName,
                version: zos_lib_1.semanticVersionToString(event.returnValues.version),
                package: event.returnValues.package
            }))
                .reduce((dependencies, dependency) => {
                dependencies[dependency.name] = dependency;
                return dependencies;
            }, {});
            return Object.values(filteredEvents);
        });
    }
}
exports.default = StatusChecker;
//# sourceMappingURL=StatusChecker.js.map