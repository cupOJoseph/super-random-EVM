"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const zos_lib_1 = require("zos-lib");
const log = new zos_lib_1.Logger('StatusFetcher');
class StatusFetcher {
    constructor(networkFile) {
        this.networkFile = networkFile;
    }
    onEndChecking() {
        log.info('Your project is up to date.');
    }
    onMismatchingVersion(expected, observed) {
        log.info(`Updating version from ${expected} to ${observed}`);
        this.networkFile.version = observed;
    }
    onMismatchingPackage(expected, observed) {
        log.info(`Updating package from ${expected} to ${observed}`);
        this.networkFile.package = { address: observed };
    }
    onMismatchingProvider(expected, observed) {
        log.info(`Updating provider from ${expected} to ${observed}`);
        this.networkFile.provider = { address: observed };
    }
    onUnregisteredLocalImplementation(expected, observed, { alias, address }) {
        log.info(`Removing unregistered local contract ${alias} ${address}`);
        this.networkFile.unsetContract(alias);
    }
    onMissingRemoteImplementation(expected, observed, { alias, address }) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractName = this.networkFile.packageFile.contract(alias) || alias;
            log.info(`Adding contract ${contractName} at ${address}`);
            const buildPath = zos_lib_1.Contracts.getLocalPath(contractName);
            if (zos_lib_1.FileSystem.exists(buildPath)) {
                const contract = zos_lib_1.Contracts.getFromLocal(contractName);
                const instance = contract.at(address);
                const remoteBodyBytecode = (yield zos_lib_1.ZWeb3.getCode(address)).replace(/^0x/, '');
                const bodyBytecodeHash = zos_lib_1.bytecodeDigest(remoteBodyBytecode);
                if (zos_lib_1.bodyCode(contract) === remoteBodyBytecode) {
                    log.warn(`Assuming that constructor function of local version of ${contractName} is the one registered`);
                    const constructor = zos_lib_1.constructorCode(contract);
                    const bytecodeHash = zos_lib_1.bytecodeDigest(`${constructor}${remoteBodyBytecode}`);
                    this.networkFile.setContract(alias, { address, localBytecodeHash: bytecodeHash, deployedBytecodeHash: bytecodeHash, bodyBytecodeHash, constructorCode: constructor });
                }
                else {
                    log.error(`Local version of ${contractName} has a different bytecode than the one stored at ${address}`);
                    this.networkFile.setContract(alias, { address, bodyBytecodeHash, localBytecodeHash: 'unknown', deployedBytecodeHash: 'unknown', constructorCode: 'unknown' });
                }
            }
            else {
                log.error(`Cannot find a contract build file for ${contractName}`);
                this.networkFile.setContract(alias, { address, localBytecodeHash: 'unknown', deployedBytecodeHash: 'unknown', constructorCode: 'unknown' });
            }
        });
    }
    onMismatchingImplementationAddress(expected, observed, { alias, address }) {
        log.info(`Updating address of contract ${alias} from ${expected} to ${observed}`);
        this.networkFile.updateImplementation(alias, (implementation) => (Object.assign({}, implementation, { address })));
    }
    onMismatchingImplementationBodyBytecode(expected, observed, { alias, address, bodyBytecodeHash }) {
        log.info(`Updating bytecodeHash of contract ${alias} from ${expected} to ${observed}`);
        this.networkFile.updateImplementation(alias, (implementation) => (Object.assign({}, implementation, { bodyBytecodeHash })));
    }
    onUnregisteredLocalProxy(expected, observed, { packageName, alias, address, implementation }) {
        log.info(`Removing unregistered local proxy of ${alias} at ${address} pointing to ${implementation}`);
        this.networkFile.removeProxy(packageName, alias, address);
    }
    onMissingRemoteProxy(expected, observed, { packageName, alias, address, implementation }) {
        log.info(`Adding missing proxy of ${alias} at ${address} pointing to ${implementation}`);
        this.networkFile.addProxy(packageName, alias, { address, version: 'unknown', implementation });
    }
    onMismatchingProxyAlias(expected, observed, { packageName, address, version, implementation }) {
        log.info(`Changing alias of package ${packageName} proxy at ${address} pointing to ${implementation} from ${expected} to ${observed}`);
        this.networkFile.removeProxy(packageName, expected, address);
        this.networkFile.addProxy(packageName, observed, { address, version, implementation });
    }
    onMismatchingProxyImplementation(expected, observed, { packageName, address, version, implementation, alias }) {
        log.info(`Changing implementation of proxy ${alias} at ${address} from ${expected} to ${observed}`);
        this.networkFile.updateProxy({ package: packageName, contract: alias, address }, (proxy) => (Object.assign({}, proxy, { implementation: observed })));
    }
    onUnregisteredProxyImplementation(expected, observed, { address, implementation }) {
        log.error(`Proxy at ${address} is pointing to ${implementation}, but given implementation is not registered in project`);
    }
    onMultipleProxyImplementations(expected, observed, { implementation }) {
        log.warn(`The same implementation address ${implementation} was registered under many aliases (${observed}). Please check them in the list of registered contracts.`);
    }
    onMissingDependency(expected, observed, { name, address, version }) {
        log.info(`Adding missing dependency ${name} at ${address} with version ${version}`);
        this.networkFile.setDependency(name, { package: address, version });
    }
    onMismatchingDependencyAddress(expected, observed, { name, address }) {
        log.info(`Changing dependency ${name} package address from ${expected} to ${observed}`);
        this.networkFile.updateDependency(name, (dependency) => (Object.assign({}, dependency, { package: observed })));
    }
    onMismatchingDependencyVersion(expected, observed, { name, version }) {
        log.info(`Changing dependency ${name} version from ${expected} to ${observed}`);
        this.networkFile.updateDependency(name, (dependency) => (Object.assign({}, dependency, { version: observed })));
    }
    onUnregisteredDependency(expected, observed, { name, package: packageAddress }) {
        log.info(`Removing unregistered local dependency of ${name} at ${packageAddress}`);
        this.networkFile.unsetDependency(name);
    }
}
exports.default = StatusFetcher;
//# sourceMappingURL=StatusFetcher.js.map