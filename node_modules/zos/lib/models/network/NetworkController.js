'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_isempty_1 = __importDefault(require("lodash.isempty"));
const lodash_intersection_1 = __importDefault(require("lodash.intersection"));
const lodash_uniqwith_1 = __importDefault(require("lodash.uniqwith"));
const lodash_uniq_1 = __importDefault(require("lodash.uniq"));
const lodash_flatten_1 = __importDefault(require("lodash.flatten"));
const lodash_filter_1 = __importDefault(require("lodash.filter"));
const lodash_every_1 = __importDefault(require("lodash.every"));
const lodash_partition_1 = __importDefault(require("lodash.partition"));
const lodash_map_1 = __importDefault(require("lodash.map"));
const lodash_foreach_1 = __importDefault(require("lodash.foreach"));
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const lodash_concat_1 = __importDefault(require("lodash.concat"));
const lodash_topairs_1 = __importDefault(require("lodash.topairs"));
const zos_lib_1 = require("zos-lib");
const zos_lib_2 = require("zos-lib");
const zos_lib_3 = require("zos-lib");
const ZosVersion_1 = require("../files/ZosVersion");
const async_1 = require("../../utils/async");
const naming_1 = require("../../utils/naming");
const ProjectDeployer_1 = require("./ProjectDeployer");
const Dependency_1 = __importDefault(require("../dependency/Dependency"));
const StatusChecker_1 = __importDefault(require("../status/StatusChecker"));
const ValidationLogger_1 = __importDefault(require("../../interface/ValidationLogger"));
const Verifier_1 = __importDefault(require("../Verifier"));
const log = new zos_lib_1.Logger('NetworkAppController');
class NetworkController {
    constructor(localController, network, txParams, networkFile) {
        this.localController = localController;
        this.txParams = txParams;
        this.network = network;
        this.networkFile = networkFile || localController.packageFile.networkFile(network);
    }
    // NetworkController
    get packageFile() {
        return this.localController.packageFile;
    }
    // NetworkController
    get packageVersion() {
        return this.packageFile.version;
    }
    // NetworkController
    get currentVersion() {
        return this.networkFile.version;
    }
    get currentZosversion() {
        return this.networkFile.zosversion;
    }
    // NetworkController
    get packageAddress() {
        return this.networkFile.packageAddress;
    }
    get proxyAdminAddress() {
        return this.networkFile.proxyAdminAddress;
    }
    // NetworkController
    checkNotFrozen() {
        if (this.networkFile.frozen) {
            throw Error('Cannot modify contracts in a frozen version. Run zos bump to create a new version first.');
        }
    }
    // StatusController
    compareCurrentStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPublished)
                throw Error('Command status-pull is not supported for unpublished projects');
            const statusComparator = StatusChecker_1.default.compare(this.networkFile, this.txParams);
            yield statusComparator.call();
        });
    }
    // StatusController
    pullRemoteStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isPublished)
                throw Error('Command status-fix is not supported for unpublished projects');
            const statusFetcher = StatusChecker_1.default.fetch(this.networkFile, this.txParams);
            yield statusFetcher.call();
        });
    }
    // DeployerController
    fetchOrDeploy(requestedVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            this.project = yield this.getDeployer(requestedVersion).fetchOrDeploy();
            return this.project;
        });
    }
    // DeployerController
    push(reupload = false, force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const changedLibraries = this._solidityLibsForPush(!reupload);
            const contracts = this._contractsListForPush(!reupload, changedLibraries);
            const buildArtifacts = zos_lib_2.getBuildArtifacts();
            // ValidateContracts also extends each contract class with validation errors and storage info
            if (!this.validateContracts(contracts, buildArtifacts) && !force) {
                throw Error('One or more contracts have validation errors. Please review the items listed above and fix them, or run this command again with the --force option.');
            }
            this._checkVersion();
            yield this.fetchOrDeploy(this.packageVersion);
            yield this.handleDependenciesLink();
            this.checkNotFrozen();
            yield this.uploadSolidityLibs(changedLibraries);
            yield Promise.all([
                this.uploadContracts(contracts),
                this.unsetContracts()
            ]);
            yield this._unsetSolidityLibs();
        });
    }
    // DeployerController
    _checkVersion() {
        if (this._newVersionRequired()) {
            log.info(`Current version ${this.currentVersion}`);
            log.info(`Creating new version ${this.packageVersion}`);
            this.networkFile.frozen = false;
            this.networkFile.contracts = {};
        }
    }
    // DeployerController
    _newVersionRequired() {
        return (this.packageVersion !== this.currentVersion) && this.isPublished;
    }
    // Contract model
    _contractsListForPush(onlyChanged = false, changedLibraries = []) {
        const newVersion = this._newVersionRequired();
        const pipeline = [
            (contracts) => lodash_topairs_1.default(contracts),
            (contracts) => lodash_map_1.default(contracts, ([contractAlias, contractName]) => [contractAlias, zos_lib_1.Contracts.getFromLocal(contractName)]),
            (contracts) => lodash_filter_1.default(contracts, ([contractAlias, contract]) => newVersion || !onlyChanged || this.hasContractChanged(contractAlias, contract) || this._hasChangedLibraries(contract, changedLibraries))
        ];
        return pipeline.reduce((xs, f) => f(xs), this.packageFile.contracts);
    }
    // Contract model || SolidityLib model
    _solidityLibsForPush(onlyChanged = false) {
        const { contractNames, contractAliases } = this.packageFile;
        const libNames = this._getAllSolidityLibNames(contractNames);
        const clashes = lodash_intersection_1.default(libNames, contractAliases);
        if (!lodash_isempty_1.default(clashes)) {
            throw new Error(`Cannot upload libraries with the same name as a contract alias: ${clashes.join(', ')}`);
        }
        return libNames
            .map((libName) => zos_lib_1.Contracts.getFromLocal(libName))
            .filter((libClass) => {
            const hasSolidityLib = this.networkFile.hasSolidityLib(libClass.schema.contractName);
            const hasChanged = this._hasSolidityLibChanged(libClass);
            return (!hasSolidityLib || !onlyChanged || hasChanged);
        });
    }
    // Contract model || SolidityLib model
    uploadSolidityLibs(libs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(libs.map((lib) => this._uploadSolidityLib(lib)));
        });
    }
    // Contract model || SolidityLib model
    _uploadSolidityLib(libClass) {
        return __awaiter(this, void 0, void 0, function* () {
            const libName = libClass.schema.contractName;
            log.info(`Uploading ${libName} library...`);
            const libInstance = yield this.project.setImplementation(libClass, libName);
            this.networkFile.addSolidityLib(libName, libInstance);
        });
    }
    // Contract model
    uploadContracts(contracts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(contracts.map(([contractAlias, contract]) => this.uploadContract(contractAlias, contract)));
        });
    }
    // Contract model
    uploadContract(contractAlias, contract) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._setSolidityLibs(contract);
                log.info(`Uploading ${contract.schema.contractName} contract as ${contractAlias}`);
                const contractInstance = yield this.project.setImplementation(contract, contractAlias);
                this.networkFile.addContract(contractAlias, contractInstance, {
                    warnings: contract.schema.warnings,
                    types: contract.schema.storageInfo.types,
                    storage: contract.schema.storageInfo.storage
                });
            }
            catch (error) {
                error.message = `${contractAlias} deployment failed with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Contract model || SolidityLib model
    _setSolidityLibs(contract) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentContractLibs = zos_lib_2.getSolidityLibNames(contract.schema.bytecode);
            const libraries = this.networkFile.getSolidityLibs(currentContractLibs);
            contract.link(libraries);
        });
    }
    // Contract model || SolidityLib model
    _unsetSolidityLibs() {
        return __awaiter(this, void 0, void 0, function* () {
            const { contractNames } = this.packageFile;
            const libNames = this._getAllSolidityLibNames(contractNames);
            yield async_1.allPromisesOrError(this.networkFile.solidityLibsMissing(libNames).map((libName) => this._unsetSolidityLib(libName)));
        });
    }
    // Contract model || SolidityLib model
    _unsetSolidityLib(libName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                log.info(`Removing ${libName} library`);
                yield this.project.unsetImplementation(libName);
                this.networkFile.unsetSolidityLib(libName);
            }
            catch (error) {
                error.message = `Removal of ${libName} failed with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Contract model || SolidityLib model
    _hasChangedLibraries(contract, changedLibraries) {
        const libNames = zos_lib_2.getSolidityLibNames(contract.schema.bytecode);
        return !lodash_isempty_1.default(lodash_intersection_1.default(changedLibraries.map((c) => c.schema.contractName), libNames));
    }
    // Contract model || SolidityLib model
    _getAllSolidityLibNames(contractNames) {
        const libNames = contractNames.map((contractName) => {
            const contract = zos_lib_1.Contracts.getFromLocal(contractName);
            return zos_lib_2.getSolidityLibNames(contract.schema.bytecode);
        });
        return lodash_uniq_1.default(lodash_flatten_1.default(libNames));
    }
    // Contract model
    unsetContracts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(this.networkFile.contractAliasesMissingFromPackage().map((contractAlias) => this.unsetContract(contractAlias)));
        });
    }
    // Contract model
    unsetContract(contractAlias) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                log.info(`Removing ${contractAlias} contract`);
                yield this.project.unsetImplementation(contractAlias);
                this.networkFile.unsetContract(contractAlias);
            }
            catch (error) {
                error.message = `Removal of ${contractAlias} failed with error: ${error.message}`;
                throw error;
            }
        });
    }
    // DeployerController || Contract model
    validateContracts(contracts, buildArtifacts) {
        return lodash_every_1.default(contracts.map(([contractAlias, contract]) => this.validateContract(contractAlias, contract, buildArtifacts)));
    }
    // DeployerController || Contract model
    validateContract(contractAlias, contract, buildArtifacts) {
        log.info(`Validating contract ${contract.schema.contractName}`);
        const existingContractInfo = this.networkFile.contract(contractAlias) || {};
        const warnings = zos_lib_3.validate(contract, existingContractInfo, buildArtifacts);
        const newWarnings = zos_lib_3.newValidationErrors(warnings, existingContractInfo.warnings);
        const validationLogger = new ValidationLogger_1.default(contract, existingContractInfo);
        validationLogger.log(newWarnings, buildArtifacts);
        contract.schema.warnings = warnings;
        contract.schema.storageInfo = zos_lib_2.getStorageLayout(contract, buildArtifacts);
        return zos_lib_3.validationPasses(newWarnings);
    }
    // Contract model
    checkContractDeployed(packageName, contractAlias, throwIfFail = false) {
        if (!packageName)
            packageName = this.packageFile.name;
        const err = this._errorForContractDeployed(packageName, contractAlias);
        if (err)
            this._handleErrorMessage(err, throwIfFail);
    }
    // Contract model
    checkLocalContractsDeployed(throwIfFail = false) {
        const err = this._errorForLocalContractsDeployed();
        if (err)
            this._handleErrorMessage(err, throwIfFail);
    }
    // Contract model
    _errorForLocalContractsDeployed() {
        const [contractsDeployed, contractsMissing] = lodash_partition_1.default(this.packageFile.contractAliases, (alias) => this.isContractDeployed(alias));
        const contractsChanged = lodash_filter_1.default(contractsDeployed, (alias) => this.hasContractChanged(alias));
        if (!lodash_isempty_1.default(contractsMissing)) {
            return `Contracts ${contractsMissing.join(', ')} are not deployed.`;
        }
        else if (!lodash_isempty_1.default(contractsChanged)) {
            return `Contracts ${contractsChanged.join(', ')} have changed since the last deploy.`;
        }
    }
    // Contract model
    checkLocalContractDeployed(contractAlias, throwIfFail = false) {
        // if (!packageName) packageName = this.packageFile.name
        const err = this._errorForLocalContractDeployed(contractAlias);
        if (err)
            this._handleErrorMessage(err, throwIfFail);
    }
    // Contract model
    _errorForLocalContractDeployed(contractAlias) {
        if (!this.isContractDefined(contractAlias)) {
            return `Contract ${contractAlias} not found in this project`;
        }
        else if (!this.isContractDeployed(contractAlias)) {
            return `Contract ${contractAlias} is not deployed to ${this.network}.`;
        }
        else if (this.hasContractChanged(contractAlias)) {
            return `Contract ${contractAlias} has changed locally since the last deploy, consider running 'zos push'.`;
        }
    }
    // TODO: move to utils folder or somewhere else
    _handleErrorMessage(msg, throwIfFail = false) {
        if (throwIfFail) {
            throw Error(msg);
        }
        else {
            log.info(msg);
        }
    }
    // Contract model || SolidityLib model
    _hasSolidityLibChanged(libClass) {
        return !this.networkFile.hasSameBytecode(libClass.schema.contractName, libClass);
    }
    // Contract model
    hasContractChanged(contractAlias, contract) {
        if (!this.isLocalContract(contractAlias))
            return false;
        if (!this.isContractDeployed(contractAlias))
            return true;
        if (!contract) {
            const contractName = this.packageFile.contract(contractAlias);
            contract = zos_lib_1.Contracts.getFromLocal(contractName);
        }
        return !this.networkFile.hasSameBytecode(contractAlias, contract);
    }
    // Contract model
    isLocalContract(contractAlias) {
        return this.packageFile.hasContract(contractAlias);
    }
    // Contract model
    isContractDefined(contractAlias) {
        return this.packageFile.hasContract(contractAlias);
    }
    // Contract model
    isContractDeployed(contractAlias) {
        return !this.isLocalContract(contractAlias) || this.networkFile.hasContract(contractAlias);
    }
    // VerifierController
    verifyAndPublishContract(contractAlias, optimizer, optimizerRuns, remote, apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractName = this.packageFile.contract(contractAlias);
            const { compilerVersion, sourcePath } = this.localController.getContractSourcePath(contractAlias);
            const contractSource = yield zos_lib_2.flattenSourceCode([sourcePath]);
            const contractAddress = this.networkFile.contracts[contractAlias].address;
            log.info(`Verifying and publishing ${contractAlias} on ${remote}`);
            yield Verifier_1.default.verifyAndPublish(remote, { contractName, compilerVersion, optimizer, optimizerRuns, contractSource, contractAddress, apiKey, network: this.network });
        });
    }
    // NetworkController
    writeNetworkPackageIfNeeded() {
        this.networkFile.write();
        this.packageFile.write();
    }
    // DeployerController
    freeze() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.packageAddress)
                throw Error('Cannot freeze an unpublished project');
            yield this.fetchOrDeploy(this.currentVersion);
            if (this.project instanceof zos_lib_2.AppProject)
                yield this.project.freeze();
            this.networkFile.frozen = true;
        });
    }
    // DeployerController
    get isPublished() {
        return this.packageFile.isPublished || this.appAddress !== undefined;
    }
    // DeployerController
    getDeployer(requestedVersion) {
        return this.isPublished
            ? new ProjectDeployer_1.AppProjectDeployer(this, requestedVersion)
            : new ProjectDeployer_1.ProxyAdminProjectDeployer(this, requestedVersion);
    }
    // NetworkController
    get appAddress() {
        return this.networkFile.appAddress;
    }
    // NetworkController
    get app() {
        if (this.project instanceof zos_lib_2.AppProject)
            return this.project.getApp();
        else
            return null;
    }
    _migrate() {
        return __awaiter(this, void 0, void 0, function* () {
            const proxies = this._fetchOwnedProxies();
            if (proxies.length !== 0) {
                const proxyAdmin = this.proxyAdminAddress
                    ? yield zos_lib_3.ProxyAdmin.fetch(this.proxyAdminAddress, this.txParams)
                    : yield zos_lib_3.ProxyAdmin.deploy(this.txParams);
                if (!this.proxyAdminAddress) {
                    log.info(`Awaiting confirmations before transferring proxies to ProxyAdmin (this may take a few minutes)`);
                    yield zos_lib_1.Transactions.awaitConfirmations(proxyAdmin.contract.deployment.transactionHash);
                }
                this._tryRegisterProxyAdmin(proxyAdmin.address);
                yield async_1.allPromisesOrError(lodash_map_1.default(proxies, (proxy) => __awaiter(this, void 0, void 0, function* () {
                    const proxyInstance = yield zos_lib_1.Proxy.at(proxy.address);
                    const currentAdmin = yield proxyInstance.admin();
                    if (currentAdmin !== proxyAdmin.address) {
                        if (this.appAddress) {
                            return zos_lib_3.AppProxyMigrator(this.appAddress, proxy.address, proxyAdmin.address, this.txParams);
                        }
                        else {
                            const simpleProject = new zos_lib_3.SimpleProject(this.packageFile.name, this.txParams);
                            return simpleProject.changeProxyAdmin(proxy.address, proxyAdmin.address);
                        }
                    }
                })));
                log.info('Successfully migrated to zosversion 2.2');
            }
            else {
                log.info('No proxies were found. Updating zosversion to 2.2');
            }
            this.updateZosVersions('2.2');
        });
    }
    _migrateZosversionIfNeeded() {
        return __awaiter(this, void 0, void 0, function* () {
            if (ZosVersion_1.isMigratableZosversion(this.currentZosversion))
                yield this._migrate();
        });
    }
    // DeployerController
    publish() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.appAddress) {
                log.info(`Project is already published to ${this.network}`);
                return;
            }
            yield this._migrateZosversionIfNeeded();
            log.info(`Publishing project to ${this.network}...`);
            const proxyAdminProject = (yield this.fetchOrDeploy(this.currentVersion));
            const deployer = new ProjectDeployer_1.AppProjectDeployer(this, this.packageVersion);
            this.project = yield deployer.fromProxyAdminProject(proxyAdminProject);
            log.info(`Publish to ${this.network} successful`);
        });
    }
    // Proxy model
    createProxy(packageName, contractAlias, initMethod, initArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            yield this.fetchOrDeploy(this.currentVersion);
            if (!packageName)
                packageName = this.packageFile.name;
            const contract = this.localController.getContractClass(packageName, contractAlias);
            yield this._setSolidityLibs(contract);
            this.checkInitialization(contract, initMethod, initArgs);
            const proxyInstance = yield this.project.createProxy(contract, { packageName, contractName: contractAlias, initMethod, initArgs });
            const implementationAddress = yield zos_lib_1.Proxy.at(proxyInstance).implementation();
            const packageVersion = packageName === this.packageFile.name ? this.currentVersion : (yield this.project.getDependencyVersion(packageName));
            yield this._tryRegisterProxyAdmin();
            yield this._updateTruffleDeployedInformation(contractAlias, proxyInstance);
            this.networkFile.addProxy(packageName, contractAlias, {
                address: proxyInstance.address,
                version: zos_lib_1.semanticVersionToString(packageVersion),
                implementation: implementationAddress
            });
            return proxyInstance;
        });
    }
    // Proxy model
    _tryRegisterProxyAdmin(adminAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.networkFile.proxyAdminAddress) {
                const proxyAdminAddress = adminAddress || (yield this.project.getAdminAddress());
                this.networkFile.proxyAdmin = { address: proxyAdminAddress };
            }
        });
    }
    // Proxy model
    checkInitialization(contract, calledInitMethod, calledInitArgs) {
        // If there is an initializer called, assume it's ok
        if (calledInitMethod)
            return;
        // Otherwise, warn the user to invoke it
        const initializeMethod = contract.schema.abi.find((fn) => fn.type === 'function' && fn.name === 'initialize');
        if (!initializeMethod)
            return;
        log.error(`Possible initialization method 'initialize' found in contract. Make sure you initialize your instance.`);
    }
    // Proxy model
    _updateTruffleDeployedInformation(contractAlias, implementation) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractName = this.packageFile.contract(contractAlias);
            if (contractName) {
                const path = zos_lib_1.Contracts.getLocalPath(contractName);
                const data = zos_lib_1.FileSystem.parseJson(path);
                if (!data.networks) {
                    data.networks = {};
                }
                const networkId = yield zos_lib_3.ZWeb3.getNetwork();
                data.networks[networkId] = {
                    links: {},
                    events: {},
                    address: implementation.address,
                    updated_at: Date.now()
                };
                zos_lib_1.FileSystem.writeJson(path, data);
            }
        });
    }
    // Proxy model
    setProxiesAdmin(packageName, contractAlias, proxyAddress, newAdmin) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            const proxies = this._fetchOwnedProxies(packageName, contractAlias, proxyAddress);
            if (proxies.length === 0)
                return [];
            yield this.fetchOrDeploy(this.currentVersion);
            yield this._changeProxiesAdmin(proxies, newAdmin);
            return proxies;
        });
    }
    // Proxy model
    _changeProxiesAdmin(proxies, newAdmin, project = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!project)
                project = this.project;
            yield async_1.allPromisesOrError(lodash_map_1.default(proxies, (aProxy) => __awaiter(this, void 0, void 0, function* () {
                yield project.changeProxyAdmin(aProxy.address, newAdmin);
                this.networkFile.updateProxy(aProxy, (anotherProxy) => (Object.assign({}, anotherProxy, { admin: newAdmin })));
            })));
        });
    }
    // Proxy model
    upgradeProxies(packageName, contractAlias, proxyAddress, initMethod, initArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._migrateZosversionIfNeeded();
            const proxies = this._fetchOwnedProxies(packageName, contractAlias, proxyAddress);
            if (proxies.length === 0)
                return [];
            yield this.fetchOrDeploy(this.currentVersion);
            // Check if there is any migrate method in the contracts and warn the user to call it
            const contracts = lodash_uniqwith_1.default(lodash_map_1.default(proxies, (p) => [p.package, p.contract]), lodash_isequal_1.default);
            lodash_foreach_1.default(contracts, ([aPackageName, contractName]) => this._checkUpgrade(this.localController.getContractClass(aPackageName, contractName), initMethod, initArgs));
            // Update all proxies loaded
            yield async_1.allPromisesOrError(lodash_map_1.default(proxies, (proxy) => this._upgradeProxy(proxy, initMethod, initArgs)));
            return proxies;
        });
    }
    // Proxy model
    _upgradeProxy(proxy, initMethod, initArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const name = { packageName: proxy.package, contractName: proxy.contract };
                const contract = this.localController.getContractClass(proxy.package, proxy.contract);
                yield this._setSolidityLibs(contract);
                const currentImplementation = yield zos_lib_1.Proxy.at(proxy.address).implementation();
                const contractImplementation = yield this.project.getImplementation(name);
                const packageVersion = proxy.package === this.packageFile.name ? this.currentVersion : (yield this.project.getDependencyVersion(proxy.package));
                let newImplementation;
                if (currentImplementation !== contractImplementation) {
                    yield this.project.upgradeProxy(proxy.address, contract, Object.assign({ initMethod, initArgs }, name));
                    newImplementation = contractImplementation;
                }
                else {
                    log.info(`Contract ${proxy.contract} at ${proxy.address} is up to date.`);
                    newImplementation = currentImplementation;
                }
                this.networkFile.updateProxy(proxy, (aProxy) => (Object.assign({}, aProxy, { implementation: newImplementation, version: zos_lib_1.semanticVersionToString(packageVersion) })));
            }
            catch (error) {
                error.message = `Proxy ${naming_1.toContractFullName(proxy.package, proxy.contract)} at ${proxy.address} failed to update with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Proxy model
    _checkUpgrade(contract, calledMigrateMethod, calledMigrateArgs) {
        // If there is a migration called, assume it's ok
        if (calledMigrateMethod)
            return;
        // Otherwise, warn the user to invoke it
        const migrateMethod = contract.schema.abi.find((fn) => fn.type === 'function' && fn.name === 'migrate');
        if (!migrateMethod)
            return;
        log.error(`Possible migration method 'migrate' found in contract ${contract.schema.contractName}. Remember running the migration after deploying it.`);
    }
    // Proxy model
    _fetchOwnedProxies(packageName, contractAlias, proxyAddress) {
        let criteriaDescription = '';
        if (packageName || contractAlias)
            criteriaDescription += ` contract ${naming_1.toContractFullName(packageName, contractAlias)}`;
        if (proxyAddress)
            criteriaDescription += ` address ${proxyAddress}`;
        const proxies = this.networkFile.getProxies({
            package: packageName || (contractAlias ? this.packageFile.name : undefined),
            contract: contractAlias,
            address: proxyAddress
        });
        if (lodash_isempty_1.default(proxies)) {
            log.info(`No contract instances that match${criteriaDescription} were found`);
            return [];
        }
        // TODO: If 'from' is not explicitly set, then we need to retrieve it from the set of current accounts
        const expectedOwner = this.isPublished ? this.appAddress : this.txParams.from;
        const ownedProxies = proxies.filter((proxy) => !proxy.admin || !expectedOwner || proxy.admin === expectedOwner);
        if (lodash_isempty_1.default(ownedProxies)) {
            log.info(`No contract instances that match${criteriaDescription} are owned by this application`);
        }
        return ownedProxies;
    }
    // Dependency Controller
    deployDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(lodash_map_1.default(this.packageFile.dependencies, (version, dep) => this.deployDependencyIfNeeded(dep, version)));
        });
    }
    // DependencyController
    deployDependencyIfNeeded(depName, depVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const dependency = new Dependency_1.default(depName, depVersion);
                if (dependency.isDeployedOnNetwork(this.network) || this.networkFile.dependencyHasMatchingCustomDeploy(depName))
                    return;
                log.info(`Deploying ${depName} contracts`);
                const deployment = yield dependency.deploy(this.txParams);
                this.networkFile.setDependency(depName, {
                    package: (yield deployment.getProjectPackage()).address,
                    version: deployment.version,
                    customDeploy: true
                });
            }
            catch (error) {
                error.message = `Failed deployment of dependency ${depName} with error: ${error.message}`;
                throw error;
            }
        });
    }
    // DependencyController
    handleDependenciesLink() {
        return __awaiter(this, void 0, void 0, function* () {
            yield async_1.allPromisesOrError(lodash_concat_1.default(lodash_map_1.default(this.packageFile.dependencies, (version, dep) => this.linkDependency(dep, version)), lodash_map_1.default(this.networkFile.dependenciesNamesMissingFromPackage(), (dep) => this.unlinkDependency(dep))));
        });
    }
    // DependencyController
    unlinkDependency(depName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (yield this.project.hasDependency(depName)) {
                    log.info(`Unlinking dependency ${depName}`);
                    yield this.project.unsetDependency(depName);
                }
                this.networkFile.unsetDependency(depName);
            }
            catch (error) {
                throw Error(`Failed to unlink dependency ${depName} with error: ${error.message}`);
            }
        });
    }
    // DependencyController
    linkDependency(depName, depVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.networkFile.dependencyHasMatchingCustomDeploy(depName)) {
                    log.info(`Using custom deployment of ${depName}`);
                    const depInfo = this.networkFile.getDependency(depName);
                    return yield this.project.setDependency(depName, depInfo.package, depInfo.version);
                }
                if (!this.networkFile.dependencySatisfiesVersionRequirement(depName)) {
                    const dependencyInfo = (new Dependency_1.default(depName, depVersion)).getNetworkFile(this.network);
                    if (!dependencyInfo.packageAddress)
                        throw Error(`Dependency '${depName}' has not been published to network '${this.network}', so it cannot be linked. Hint: you can create a custom deployment of all unpublished dependencies by running 'zos push' with the '--deploy-dependencies' option.`);
                    log.info(`Connecting to dependency ${depName} ${dependencyInfo.version}`);
                    yield this.project.setDependency(depName, dependencyInfo.packageAddress, dependencyInfo.version);
                    const depInfo = { package: dependencyInfo.packageAddress, version: dependencyInfo.version };
                    this.networkFile.setDependency(depName, depInfo);
                }
            }
            catch (error) {
                error.message = `Failed to link dependency ${depName}@${depVersion} with error: ${error.message}`;
                throw error;
            }
        });
    }
    // Contract model
    _errorForContractDeployed(packageName, contractAlias) {
        if (packageName === this.packageFile.name) {
            return this._errorForLocalContractDeployed(contractAlias);
        }
        else if (!this.packageFile.hasDependency(packageName)) {
            return `Dependency ${packageName} not found in project.`;
        }
        else if (!this.networkFile.hasDependency(packageName)) {
            return `Dependency ${packageName} has not been linked yet. Please run zos push.`;
        }
        else if (!(new Dependency_1.default(packageName)).getPackageFile().contract(contractAlias)) {
            return `Contract ${contractAlias} is not provided by ${packageName}.`;
        }
    }
    updateZosVersions(version) {
        this.networkFile.zosversion = version;
        this.packageFile.zosversion = version;
    }
}
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map